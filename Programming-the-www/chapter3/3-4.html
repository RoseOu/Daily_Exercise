<!--
3-4. 创建一个HTML文档，该文档的文本至少占半个页面，并有较小的一块文本嵌入页面的左边缘中，而且主要的文本能够环绕着左边这个文本块。文本块中的文本字体必须小于主文本的字体，而且以斜体显示。最后对该文档进行测试。
-->
<!DOCTYPE html>
<html>
	<head>
		<title>3-4</title>
		<meta charset="utf-8" />
		<style type="text/css">
			div.top {
				width: 0px;
			    height: 80px;
			    float: left;
			}
			div.single {
				width: 400px;
				margin: 10px 10px 10px 10px;
				float: left;
				clear: both;
				font-style: italic;
				font-size: 0.7em;
			}
			p.word {
				font-size: 1.1em;
			}
		</style>
	</head>
	<body>
		<div class="top"></div>
		<div class="single">
			<p>fork函数调用一次，返回两次。它在调用进程（称为父进程）中返回一次，返回值是新派生进程（称为子进程）的进程ID号；在子进程中返回一次，返回值为0。因此，返回值本身告知当前进程是子进程还是父进程。fork在子进程返回0而不是父进程的进程ID的原因在于：任何子进程只有一个父进程，而且子进程总是可以通过调用getppid取得父进程的进程ID。相反，父进程可以有很多子进程，而且无法获取各个子进程的进程ID。如果父进程想要跟踪所有子进程的进程ID，那么它必须记录每次调用fork的返回值。另外，进程ID 0总是由内核交换进程使用，所以一个子进程的进程ID不可能为0。子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。父、子进程并不共享这些存储空间部分。父、子进程共享代码段。由于在fork之后经常跟随着exec，所以现在的很多实现并不执行一个父进程数据段、堆和栈的完全复制。作为替代，使用了写时复制（Copy-On-Write, COW）技术。这些区域由父、子进程共享，而且内核将它们的访问权限改变为只读的。如果父、子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储器系统的一“页”。</p>
		</div>
		<p class="word">fork函数调用一次，返回两次。它在调用进程（称为父进程）中返回一次，返回值是新派生进程（称为子进程）的进程ID号；在子进程中返回一次，返回值为0。因此，返回值本身告知当前进程是子进程还是父进程。fork在子进程返回0而不是父进程的进程ID的原因在于：任何子进程只有一个父进程，而且子进程总是可以通过调用getppid取得父进程的进程ID。相反，父进程可以有很多子进程，而且无法获取各个子进程的进程ID。如果父进程想要跟踪所有子进程的进程ID，那么它必须记录每次调用fork的返回值。另外，进程ID 0总是由内核交换进程使用，所以一个子进程的进程ID不可能为0。子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。父、子进程并不共享这些存储空间部分。父、子进程共享代码段。由于在fork之后经常跟随着exec，所以现在的很多实现并不执行一个父进程数据段、堆和栈的完全复制。作为替代，使用了写时复制（Copy-On-Write, COW）技术。这些区域由父、子进程共享，而且内核将它们的访问权限改变为只读的。如果父、子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储器系统的一“页”。fork函数调用一次，返回两次。它在调用进程（称为父进程）中返回一次，返回值是新派生进程（称为子进程）的进程ID号；在子进程中返回一次，返回值为0。因此，返回值本身告知当前进程是子进程还是父进程。fork在子进程返回0而不是父进程的进程ID的原因在于：任何子进程只有一个父进程，而且子进程总是可以通过调用getppid取得父进程的进程ID。相反，父进程可以有很多子进程，而且无法获取各个子进程的进程ID。如果父进程想要跟踪所有子进程的进程ID，那么它必须记录每次调用fork的返回值。另外，进程ID 0总是由内核交换进程使用，所以一个子进程的进程ID不可能为0。子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。父、子进程并不共享这些存储空间部分。父、子进程共享代码段。由于在fork之后经常跟随着exec，所以现在的很多实现并不执行一个父进程数据段、堆和栈的完全复制。作为替代，使用了写时复制（Copy-On-Write, COW）技术。这些区域由父、子进程共享，而且内核将它们的访问权限改变为只读的。如果父、子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储器系统的一“页”。fork函数调用一次，返回两次。它在调用进程（称为父进程）中返回一次，返回值是新派生进程（称为子进程）的进程ID号；在子进程中返回一次，返回值为0。因此，返回值本身告知当前进程是子进程还是父进程。fork在子进程返回0而不是父进程的进程ID的原因在于：任何子进程只有一个父进程，而且子进程总是可以通过调用getppid取得父进程的进程ID。相反，父进程可以有很多子进程，而且无法获取各个子进程的进程ID。如果父进程想要跟踪所有子进程的进程ID，那么它必须记录每次调用fork的返回值。另外，进程ID 0总是由内核交换进程使用，所以一个子进程的进程ID不可能为0。子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。父、子进程并不共享这些存储空间部分。父、子进程共享代码段。由于在fork之后经常跟随着exec，所以现在的很多实现并不执行一个父进程数据段、堆和栈的完全复制。作为替代，使用了写时复制（Copy-On-Write, COW）技术。这些区域由父、子进程共享，而且内核将它们的访问权限改变为只读的。如果父、子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储器系统的一“页”。</p>
	</body>
</html>