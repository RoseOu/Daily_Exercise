<!-- 
3-3 创建一个HTML文档，该文档至少包含两张图片，并且还应该包含足够多的文字，这些文字出现在图片的上方，并包围着两张图片（一张图片居左，另一张图片居右），在图片的下方还应该包含文字。最后对该文档进行测试。
 -->
 <!DOCTYPE html>
 <html>
 	<head>
 		<title>3-3</title>
 		<meta charset="utf-8" />
 		<style type="text/css">
			div.wrap-div-topSpacer {
			    width: 0px;
			    height: 70px;
			    float: left;
			}
			img{
				width: 324px;
				height: 216px;
			}
			div.wrap-div-left {
				clear: both;
				margin: 20px 20px 20px 20px;
			    float: left;
			    text-align: center;
			}
			div.wrap-div-right {
				margin: 20px 20px 20px 20px;
			    float: right;
			    text-align: center;
			}
 		</style>
 	</head>
 	<body>
 		<div class="wrap-div-topSpacer"></div>
 		<div class="wrap-div-left">
			<img src="1.jpg" alt="picture 1" />
		</div>
		<div class="wrap-div-right">
			<img src="2.jpg" alt="Picture 2" />
		</div>
	 	<p>fork函数调用一次，返回两次。它在调用进程（称为父进程）中返回一次，返回值是新派生进程（称为子进程）的进程ID号；在子进程中返回一次，返回值为0。因此，返回值本身告知当前进程是子进程还是父进程。fork在子进程返回0而不是父进程的进程ID的原因在于：任何子进程只有一个父进程，而且子进程总是可以通过调用getppid取得父进程的进程ID。相反，父进程可以有很多子进程，而且无法获取各个子进程的进程ID。如果父进程想要跟踪所有子进程的进程ID，那么它必须记录每次调用fork的返回值。另外，进程ID 0总是由内核交换进程使用，所以一个子进程的进程ID不可能为0。子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。父、子进程并不共享这些存储空间部分。父、子进程共享代码段。由于在fork之后经常跟随着exec，所以现在的很多实现并不执行一个父进程数据段、堆和栈的完全复制。作为替代，使用了写时复制（Copy-On-Write, COW）技术。这些区域由父、子进程共享，而且内核将它们的访问权限改变为只读的。如果父、子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储器系统的一“页”。fork函数调用一次，返回两次。它在调用进程（称为父进程）中返回一次，返回值是新派生进程（称为子进程）的进程ID号；在子进程中返回一次，返回值为0。因此，返回值本身告知当前进程是子进程还是父进程。fork在子进程返回0而不是父进程的进程ID的原因在于：任何子进程只有一个父进程，而且子进程总是可以通过调用getppid取得父进程的进程ID。相反，父进程可以有很多子进程，而且无法获取各个子进程的进程ID。如果父进程想要跟踪所有子进程的进程ID，那么它必须记录每次调用fork的返回值。另外，进程ID 0总是由内核交换进程使用，所以一个子进程的进程ID不可能为0。子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。父、子进程并不共享这些存储空间部分。父、子进程共享代码段。由于在fork之后经常跟随着exec，所以现在的很多实现并不执行一个父进程数据段、堆和栈的完全复制。作为替代，使用了写时复制（Copy-On-Write, COW）技术。这些区域由父、子进程共享，而且内核将它们的访问权限改变为只读的。如果父、子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储器系统的一“页”。fork函数调用一次，返回两次。它在调用进程（称为父进程）中返回一次，返回值是新派生进程（称为子进程）的进程ID号；在子进程中返回一次，返回值为0。因此，返回值本身告知当前进程是子进程还是父进程。fork在子进程返回0而不是父进程的进程ID的原因在于：任何子进程只有一个父进程，而且子进程总是可以通过调用getppid取得父进程的进程ID。相反，父进程可以有很多子进程，而且无法获取各个子进程的进程ID。如果父进程想要跟踪所有子进程的进程ID，那么它必须记录每次调用fork的返回值。另外，进程ID 0总是由内核交换进程使用，所以一个子进程的进程ID不可能为0。子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。父、子进程并不共享这些存储空间部分。父、子进程共享代码段。由于在fork之后经常跟随着exec，所以现在的很多实现并不执行一个父进程数据段、堆和栈的完全复制。作为替代，使用了写时复制（Copy-On-Write, COW）技术。这些区域由父、子进程共享，而且内核将它们的访问权限改变为只读的。如果父、子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储器系统的一“页”。</p>
 	</body>
 </html>